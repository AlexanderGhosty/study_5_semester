# Лабораторная работа №4 - TCP Client-Server для передачи файлов

## Описание

Лабораторная работа по компьютерным сетям, демонстрирующая создание TCP клиент-серверного приложения на C++ для передачи файлов. Реализует надежный протокол обмена файлами между клиентом и сервером с использованием Windows Sockets API, с полной валидацией ввода и защитой от ошибок.

## Структура проекта

```
Client-Server/
├── Client-Server.sln            # Solution файл Visual Studio
├── client/                      # Клиентское приложение
│   ├── client.cpp              # Исходный код клиента
│   ├── client.vcxproj          # Проект Visual Studio
│   └── client.vcxproj.filters  # Фильтры проекта
├── Client-Server/               # Серверное приложение
│   ├── server.cpp              # Исходный код сервера
│   ├── Client-Server.vcxproj   # Проект Visual Studio
│   ├── Client-Server.vcxproj.filters # Фильтры проекта
│   └── uploads/                # Папка для загруженных файлов (создается автоматически)
├── .gitignore                  # Игнорируемые файлы
└── README.md                   # Документация (этот файл)
```

## Функциональность

### Серверная часть (`server.cpp`)
- **TCP сервер** на порту 8080
- **Надежный протокол передачи** с заголовками (команда, имя файла, размер)
- **Команды**:
  - `UPLOAD` - получение файла от клиента с произвольным именем
  - `DOWNLOAD` - отправка запрошенного файла клиенту
  - `EXIT` - корректное завершение соединения
- **Автоматическое создание папки** uploads/ для сохранения файлов
- **Гарантированная передача данных** через функции `sendAll/recvAll`
- **Полная обработка ошибок** с информативными сообщениями
- **Отображение информации о клиенте** (IP-адрес и порт)
- **Поддержка файлов любого размера** с корректной буферизацией

### Клиентская часть (`client.cpp`)
- **TCP клиент** для подключения к серверу
- **Интерактивный консольный интерфейс** с валидацией ввода
- **Функции**:
  - Загрузка файла на сервер с выбором имени (`uploadFile`)
  - Скачивание файла с сервера по имени (`downloadFile`)
  - Интерактивное взаимодействие с защитой от некорректного ввода
- **Полная валидация ввода**:
  - Проверка корректности числовых значений с очисткой потока
  - Проверка диапазона значений меню (1-3)
  - Корректная обработка состояния потока `cin.fail()`
- **Валидация IP-адреса** сервера через `inet_pton`
- **Надежная передача** файлов с проверкой размера
- **Обработка всех сетевых ошибок** с кодами WSA

## Компиляция и сборка

### Требования
- **Visual Studio** 2019/2022 или совместимая среда
- **C++14** или выше
- **Windows SDK** с поддержкой Winsock2
- **Библиотека ws2_32.lib** (подключается автоматически)

### Сборка через Visual Studio
1. Откройте `Client-Server.sln`
2. Выберите конфигурацию (Debug/Release)
3. Соберите решение (Build → Build Solution или Ctrl+Shift+B)

### Сборка через командную строку
```bash
# Для сервера
cl /EHsc /std:c++14 server.cpp ws2_32.lib

# Для клиента  
cl /EHsc /std:c++14 client.cpp ws2_32.lib
```

## Запуск

### 1. Запуск сервера
```bash
# Из папки Client-Server/Debug или Release
./Client-Server.exe
```

Вывод сервера:
```
========================================
Сервер запущен на порту 8080
Ожидание подключения клиентов...
========================================
```

### 2. Запуск клиента
```bash
# Из папки client/Debug или Release
./client.exe
```

При запуске клиент запросит IP-адрес сервера:
```
Введите IP-адрес сервера (Enter - 127.0.0.1): 
```

Нажмите Enter для использования localhost или введите IP-адрес сервера.

## Использование

### Интерфейс клиента
После подключения к серверу доступно меню:
```
========== МЕНЮ ==========
1. Отправить файл на сервер (upload)
2. Скачать файл с сервера (download)
3. Выйти
==========================
Введите номер команды (1-3): 
```
**Валидация ввода:**
- При вводе некорректного символа будет запрошен повторный ввод
- При вводе числа вне диапазона 1-3 будет показано сообщение об ошибке
- Буфер ввода автоматически очищается после каждой операции

### Загрузка файла на сервер
1. Выберите опцию `1`
2. Введите путь к локальному файлу (например, `test.txt` или `C:\files\document.pdf`)
3. Введите имя для сохранения на сервере (Enter - использовать оригинальное имя)
4. Файл будет передан на сервер и сохранен в папке `uploads/`

**Пример:**
```
Введите путь к файлу для отправки: myfile.txt
Введите имя для сохранения на сервере (Enter - оригинальное имя): document.txt
Отправка файла "myfile.txt" (1234 байт) как "document.txt"...
Файл успешно отправлен (1234 байт).
Ответ сервера: Файл успешно загружен на сервер.
```

### Скачивание файла с сервера
1. Выберите опцию `2`
2. Введите имя файла на сервере (например, `document.txt`)
3. Введите локальное имя для сохранения (Enter - использовать имя с сервера)
4. Файл будет загружен и сохранен локально

**Пример:**
```
Введите имя файла на сервере для скачивания: document.txt
Введите имя для сохранения (Enter - использовать имя с сервера): downloaded.txt
Получение файла "document.txt" (1234 байт)...
Файл успешно скачан и сохранен как "downloaded.txt" (1234 байт).
```

## Протокол взаимодействия

### Структура протокола

Протокол использует **структурированные сообщения** с префиксами длины:

#### Базовые типы данных
- **Строка**: `[8 байт длина][данные]`
- **Число int64**: `[8 байт в network byte order]`

#### Команда UPLOAD
```
Клиент → Сервер:
1. Строка "UPLOAD"
2. Строка с именем файла
3. int64 размер файла
4. Байты файла (точно указанное количество)

Сервер → Клиент:
5. Строка с результатом ("Файл успешно загружен на сервер." или сообщение об ошибке)
```

#### Команда DOWNLOAD
```
Клиент → Сервер:
1. Строка "DOWNLOAD"
2. Строка с именем файла

Сервер → Клиент:
3. Строка со статусом ("OK" или "ERROR")
4. Если OK:
   - int64 размер файла
   - Байты файла (точно указанное количество)
5. Если ERROR:
   - Строка с сообщением об ошибке
```

#### Команда EXIT
```
Клиент → Сервер:
1. Строка "EXIT"
2. Соединение закрывается
```

### Гарантированная передача данных

Реализованы функции для надежной передачи:

- **`sendAll()`** - гарантирует отправку всех байтов, обрабатывая частичные `send()`
- **`recvAll()`** - гарантирует получение точного количества байтов
- **`sendInt64()`/`recvInt64()`** - передача чисел в network byte order
- **`sendString()`/`recvString()`** - передача строк с префиксом длины

### Обработка ошибок
- Проверка `recv() == 0` как корректное закрытие соединения
- Проверка `send()/recv() == SOCKET_ERROR` с выводом кода ошибки
- Валидация размеров файлов и длин строк
- Разделение статусных сообщений и данных файлов

## Пример работы

### Консоль сервера
```
========================================
Сервер запущен на порту 8080
Ожидание подключения клиентов...
========================================

>>> Клиент подключен: 127.0.0.1:52341
Получена команда: UPLOAD
Получение файла "test.txt" (1234 байт)...
Файл успешно получен и сохранен: uploads/test.txt (1234 байт).
Получена команда: DOWNLOAD
Запрос на скачивание файла "test.txt"...
Отправка файла "test.txt" (1234 байт)...
Файл успешно отправлен клиенту (1234 байт).
Получена команда: EXIT
Клиент завершил соединение.
>>> Клиент отключен: 127.0.0.1:52341
```

### Консоль клиента
```
Введите IP-адрес сервера (Enter - 127.0.0.1): 
Используется адрес по умолчанию: 127.0.0.1
Попытка подключения к серверу 127.0.0.1:8080...
Подключение к серверу успешно установлено.

========== МЕНЮ ==========
1. Отправить файл на сервер (upload)
2. Скачать файл с сервера (download)
3. Выйти
==========================
Введите номер команды (1-3): 1

Введите путь к файлу для отправки: test.txt
Введите имя для сохранения на сервере (Enter - оригинальное имя): 
Отправка файла "test.txt" (1234 байт) как "test.txt"...
Файл успешно отправлен (1234 байт).
Ответ сервера: Файл успешно загружен на сервер.

========== МЕНЮ ==========
1. Отправить файл на сервер (upload)
2. Скачать файл с сервера (download)
3. Выйти
==========================
Введите номер команды (1-3): 2

Введите имя файла на сервере для скачивания: test.txt
Введите имя для сохранения (Enter - использовать имя с сервера): downloaded.txt
Получение файла "test.txt" (1234 байт)...
Файл успешно скачан и сохранен как "downloaded.txt" (1234 байт).

========== МЕНЮ ==========
1. Отправить файл на сервер (upload)
2. Скачать файл с сервера (download)
3. Выйти
==========================
Введите номер команды (1-3): 3

Завершение работы клиента...
Закрытие соединения...
Соединение закрыто.
```

## Особенности реализации

### Надежность передачи
- **Гарантированная доставка** всех байтов через `sendAll/recvAll`
- **Обработка частичных send/recv** в цикле до полной передачи
- **Проверка размера** передаваемых данных на каждом этапе
- **Network byte order** для чисел (_byteswap_uint64)

### Защита от ошибок
- **Полная валидация пользовательского ввода**:
  - Проверка `std::cin.fail()` после каждого ввода
  - Очистка потока через `cin.clear()` и `cin.ignore()`
  - Проверка диапазонов значений
- **Валидация сетевых данных**:
  - Проверка размеров файлов (не отрицательные, в разумных пределах)
  - Ограничение длины строк (максимум 1 МБ)
  - Проверка статусов операций
- **Обработка сетевых ошибок**:
  - Проверка всех возвращаемых значений сокетных функций
  - Вывод кодов ошибок WSA
  - Корректное закрытие соединений

### Масштабируемость
- **Файлы любого размера**: буферизованная передача по 4096 байт
- **Произвольные имена файлов**: клиент и сервер согласуют имена
- **Бинарная передача**: поддержка файлов любого типа
- **Увеличенный буфер**: 4096 байт вместо 1024 для лучшей производительности

## Технические детали

### Константы
```cpp
#define PORT 8080           // Порт сервера
#define BUFFER_SIZE 4096    // Размер буфера передачи
```

### Ключевые функции

**Передача данных:**
- `sendAll()` - гарантированная отправка N байт
- `recvAll()` - гарантированное получение N байт
- `sendInt64()` / `recvInt64()` - передача 64-битных чисел
- `sendString()` / `recvString()` - передача строк с длиной

**Валидация ввода:**
- `getIntInput()` - безопасный ввод целого числа с проверкой диапазона
- `getStringInput()` - безопасный ввод строки

**Обработка файлов:**
- `uploadFile()` - отправка файла на сервер
- `downloadFile()` - получение файла с сервера
- `handleUpload()` - обработка загрузки на сервере
- `handleDownload()` - обработка скачивания на сервере

## Ограничения

- Работает только на **Windows** (использует Winsock2 API)
- Сервер обрабатывает **одного клиента** последовательно (для многопользовательского режима нужны потоки)
- Нет **аутентификации** или **шифрования** (для учебных целей)
- Нет **возобновления** прерванной передачи
- Имена файлов ограничены **1 МБ** (для защиты от атак)
